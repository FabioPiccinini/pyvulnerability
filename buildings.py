from pathlib import Path, PurePath
import csv
import re
import numpy as np
import enum

from typing import Union



import qgis.core
import qgis.utils
import plugins.processing as processing

import qgis.PyQt.QtCore
import qgis.PyQt.QtWidgets




class ShapePlReg(enum.Enum):
    Yes = 'Y'
    No = 'N'
    Enough = 'E'



class Side(enum.Enum):
    Front = 'front'
    Left = 'left'
    Right = 'right'
    Back = 'back'



class PlanLoc(enum.Enum):
    
    Center = 'C'
    Angle = 'A'
    End = 'E'
    Isolated = qgis.core.NULL



class DifHeight(enum.Enum):
    
    Yes = 'Y'
    No = 'N'
    Isolated = qgis.core.NULL



field_var_suffix = "_field"
layer_var_suffix = "_layer"



class MessageBoxType(enum.Enum):

    Question = ('Question', qgis.PyQt.QtWidgets.QMessageBox.question)
    Information = ('Information', qgis.PyQt.QtWidgets.QMessageBox.information)
    Warning = ('Warning', qgis.PyQt.QtWidgets.QMessageBox.warning)
    Critical = ('Critical', qgis.PyQt.QtWidgets.QMessageBox.critical)



def message_box(
    type: MessageBoxType,
    parent: qgis.PyQt.QtWidgets.QWidget = None,
    title: str = None,
    text: str = None,
    **kwargs
    ):

    if not title: title = type.value[0]

    type.value[1](parent, title, text, **kwargs)



def field_var_name(default_field_name: str) -> str:
    return default_field_name + field_var_suffix



def layer_var_name(default_layer_name: str) -> str:
    return default_layer_name + layer_var_suffix



def check_layer_field_var_and_setup(
    main_layer: qgis.core.QgsVectorLayer,
    default_field_name: str,
    req_type: qgis.PyQt.QtCore.QVariant.Type = qgis.PyQt.QtCore.QVariant.Invalid,
    req_len: int = 0,
    req_prec: int = 0
    ):

    if check_layer_field_var(main_layer=main_layer, default_field_name=default_field_name):
        if check_field_properties_and_setup(field=default_field_name, layer=main_layer, req_type=req_type, req_len=req_len, req_prec=req_prec): return

    field = add_field(
        layer=main_layer,
        field_name=default_field_name,
        type=req_type,
        len=req_len,
        prec=req_prec
        )

    set_layer_field_var(main_layer=main_layer, default_field_name=default_field_name, value=field.name())
    print(f"The variable {field_var_name(default_field_name)} has been set to the added default field {default_field_name}")



def check_layer_layer_var(
    main_layer: qgis.core.QgsVectorLayer,
    default_layer_name: str
    ) -> bool:

    var_name = layer_var_name(default_layer_name)
    var_value = qgis.core.QgsExpressionContextUtils.layerScope(main_layer).variable(var_name)

    if var_value:
        match_list = qgis.core.QgsProject.instance().mapLayersByName(layerName=var_value)
        if match_list: 
            print(f"The variable {var_name} was valid")
            return True

    match_list = qgis.core.QgsProject.instance().mapLayersByName(layerName=default_layer_name)
    if match_list: 
        set_layer_layer_var(main_layer=main_layer, default_layer_name=default_layer_name, value=default_layer_name)
        print(f"The variable {var_name} has been set to the existing layer {default_layer_name}")
        return True

    set_layer_layer_var(main_layer=main_layer, default_layer_name=default_layer_name)
    print(f"The variable {var_name} was not valid and the default layer did not exist")
    return False


    
def check_layer_field_var(
    main_layer: qgis.core.QgsVectorLayer,
    default_field_name: str
    ) -> bool:

    var_name = field_var_name(default_field_name)
    var_value = qgis.core.QgsExpressionContextUtils.layerScope(main_layer).variable(var_name)

    fields = main_layer.fields()

    if var_value:
        index = fields.indexFromName(var_value)
        if index != -1:
            print(f"The variable {var_name} was valid")
            return True

    index = fields.indexFromName(default_field_name)
    if index != -1:
        set_layer_field_var(main_layer=main_layer, default_field_name=default_field_name, value=default_field_name)
        print(f"The variable {var_name} has been set to the existing field {default_field_name}")
        return True

    set_layer_field_var(main_layer=main_layer, default_field_name=default_field_name)
    print(f"The variable {var_name} was not valid and the default field did not exist")
    return False



def check_field_properties_and_setup(
    field: Union[int, str, qgis.core.QgsField],
    layer: qgis.core.QgsVectorLayer = None,
    req_type: qgis.PyQt.QtCore.QVariant.Type = qgis.PyQt.QtCore.QVariant.Invalid,
    req_len: int = 0,
    req_prec: int = 0
    ) -> bool:
    
    if layer:
        if isinstance(field, str):
            index = layer.fields().indexFromName(field)
            if index == -1: index = layer.fields().indexFromName(qgis.core.QgsExpressionContextUtils.layerScope(layer).variable(field_var_name(field)))
            if index == -1: return False
            field = index

        if isinstance(field, int):
            try: field = layer.fields()[field]
            except: return False

    if not isinstance(field, qgis.core.QgsField): return False


    if field.length() < req_len and field.length() != 0 : field.setLength(req_len)

    if field.precision() < req_prec and field.precision() != 0 : field.setPrecision(req_prec)

    if field.type() != req_type:  return False

    print(f"Field {field.name()} is of the type {field.type()} and {req_type} was required")
    return True



def add_field(
    layer: qgis.core.QgsVectorLayer,
    field_name: str,
    type: qgis.PyQt.QtCore.QVariant.Type = qgis.PyQt.QtCore.QVariant.Invalid,
    len: int = 0,
    prec: int = 0
    ) -> qgis.core.QgsField:

    prog_num = 1
    while layer.fields().indexFromName(field_name) != -1:
        prog_num += 1
        field_name = field_name + " " + str(prog_num)

    field = qgis.core.QgsField(
        name = field_name,
        type = type,
        len = len,
        prec = prec
        )

    pr = layer.dataProvider()
    pr.addAttributes([field])
    layer.updateFields()

    #layer.addAttribute(field = field)

    return field


    
def set_layer_field_var(
    main_layer: qgis.core.QgsVectorLayer,
    default_field_name: str,
    value: str = ""
    ):
        
    qgis.core.QgsExpressionContextUtils.setLayerVariable(layer=main_layer, name=field_var_name(default_field_name), value=value)



def set_layer_layer_var(
    main_layer: qgis.core.QgsVectorLayer,
    default_layer_name: str,
    value: str = ""
    ):
        
    qgis.core.QgsExpressionContextUtils.setLayerVariable(layer=main_layer, name=layer_var_name(default_layer_name), value=value)



def field_default_name_from_fieldname_in_layer(
    layer: qgis.core.QgsVectorLayer,
    field_name: str
    ) -> str:

    layer_scope = qgis.core.QgsExpressionContextUtils.layerScope(layer)

    variables_name_list = layer_scope.filteredVariableNames()

    for variable_name in variables_name_list:

        match = re.search(re.compile('^(.*)' + field_var_suffix + '$'), variable_name)

        if match:
            if layer_scope.variable(variable_name) == field_name: return match.group(1)

    return None



def find_node_parent_and_index(node: qgis.core.QgsLayerTreeNode) -> (qgis.core.QgsLayerTreeNode, int):

    parent = node.parent()
    children = parent.children()

    for index in range(0, len(children)):

        if children[index].nodeType() == node.nodeType() and children[index].name() == node.name():
            return (parent, index)
        
    return (parent, None)



def layer_from_name(layer_name: str) -> list[qgis.core.QgsVectorLayer]:

    project = qgis.core.QgsProject.instance()

    layer_list = project.mapLayersByName(layerName=layer_name)

    return layer_list



def check_layer_in_group(
    layer: qgis.core.QgsVectorLayer,
    group: qgis.core.QgsLayerTreeGroup
    ) -> qgis.core.QgsLayerTreeLayer:

    layer_tree_layer = group.findLayer(layer)
    return layer_tree_layer



def move_loaded_layer_in_group(
    layer: qgis.core.QgsVectorLayer,
    group: qgis.core.QgsLayerTreeGroup
    ):

    root = qgis.core.QgsProject.instance().layerTreeRoot()

    layer_tree_node = root.findLayer(layer.id())
    layer_tree_node_clone = layer_tree_node.clone()
    parent = layer_tree_node.parent()

    group.insertChildNode(index=0, node=layer_tree_node_clone)

    parent.removeChildNode(layer_tree_node)



def create_group(
    name: str,
    in_group: qgis.core.QgsLayerTreeGroup = None,
    above_layer: qgis.core.QgsVectorLayer = None,
    under_layer: qgis.core.QgsVectorLayer = None
    ) -> qgis.core.QgsLayerTreeGroup:

    project = qgis.core.QgsProject.instance()
    root = project.layerTreeRoot()
    parent = None
    index = None

    if under_layer:
        under_layer_node = root.findLayer(under_layer)
        if under_layer_node:
            (parent, index) = find_node_parent_and_index(under_layer_node)
            index += 1
    elif above_layer:
        above_layer_node = root.findLayer(above_layer)
        if above_layer_node:
            (parent, index) = find_node_parent_and_index(above_layer_node)
    elif in_group:
        parent = in_group

    if not parent: parent = root
    if not index: index = 0

    prog_num = 1
    while root.findGroup(name):
        prog_num += 1
        name = name + " " + str(prog_num)

    group = parent.insertGroup(index=index, name=name)

    return group



def add_layer_to_project(
    layer: qgis.core.QgsVectorLayer,
    in_group: qgis.core.QgsLayerTreeGroup = None,
    name: str = None
    ):

    project = qgis.core.QgsProject.instance()
    if not in_group: in_group = project.layerTreeRoot()

    if name: layer.setName(name)
    project.addMapLayer(layer, False)
    in_group.insertLayer(index = 0, layer=layer)



def remove_group_and_all_children(group: qgis.core.QgsLayerTreeGroup):
    
    group.removeAllChildren()
    group.parent().removeChildNode(group)



def exec_process_vect_layer_add_results(
    algorithm_name: str,
    parameters: dict,
    vector_layer: qgis.core.QgsVectorLayer,
    vector_layer_param_name: str,
    expected_fields_names_result: list[str],
    selected_features_only: bool = False
    ):

    feature_request = qgis.core.QgsFeatureRequest()

    orig_fields = vector_layer.fields()
    orig_fields_names = [field.name() for field in orig_fields]

    subset_fields_names = [field_name for field_name in orig_fields_names if field_name not in expected_fields_names_result]
    feature_request.setSubsetOfAttributes(subset_fields_names, orig_fields)


    if selected_features_only:
        features_ids_to_update = [feature.id() for feature in vector_layer.getSelectedFeatures()]
        feature_request.setFilterFids(vector_layer.selectedFeatureIds())
    else:
        features_ids_to_update = [feature.id() for feature in vector_layer.getFeatures()]


    temp_layer = vector_layer.materialize(feature_request)
    project = qgis.core.QgsProject.instance()
    project.addMapLayer(temp_layer, False)
    temp_layer.setName('temp_layer')
    parameters[vector_layer_param_name] = 'temp_layer'


    results = processing.run(algorithm_name, parameters)
    layer_result = results['OUTPUT']
    project.addMapLayer(layer_result, False)
    features_result = [*(layer_result.getFeatures())]

    project.removeMapLayer(temp_layer.id())


    fields_to_check = []
    fields_to_add = []

    for field in layer_result.fields():
        if field.name() in expected_fields_names_result:
            if field.name() in orig_fields_names: fields_to_check.append(field)
            else: fields_to_add.append(field)


    fields_indexes_to_delete = []
    for field in fields_to_check:
        if not check_field_properties_and_setup(
            field = field.name(),
            layer = vector_layer,
            req_type = field.type(),
            req_len = field.length(),
            req_prec = field.precision()
            ):

            fields_indexes_to_delete.append(orig_fields.indexFromName(field.name()))
            fields_to_add.append(field)

    vector_layer.deleteAttributes(fields_indexes_to_delete)


    print(fields_to_add)
    for field in fields_to_add:
        add_field(
            layer = vector_layer,
            field_name = field.name(),
            type = field.type(),
            len = field.length(),
            prec = field.precision()
            )
        #vector_layer.commitChanges()
        #vector_layer.startEditing()

    for i in range(len(features_ids_to_update)):
        for field_name in expected_fields_names_result:
            vector_layer.changeAttributeValue(
                fid = features_ids_to_update[i],
                field = vector_layer.fields().indexFromName(field_name),
                newValue = features_result[i][field_name]
                )

    project.removeMapLayer(layer_result.id())



def execute_field_calculator(
    vector_layer: qgis.core.QgsVectorLayer,
    expression: Union[str, qgis.core.QgsExpression],
    result_field: Union[int, str, qgis.core.QgsField],
    req_type: qgis.PyQt.QtCore.QVariant.Type = qgis.PyQt.QtCore.QVariant.Invalid,
    req_len: int = 0,
    req_prec: int = 0,
    selected_features_only: bool = False
    ):

    if isinstance(expression, str): expression = qgis.core.QgsExpression(expression)


    vector_layer_fields = vector_layer.fields()


    if isinstance(result_field, qgis.core.QgsField):
        result_field_name = result_field.name()
        result_field_index = vector_layer_fields.indexFromName(result_field_name)


    elif isinstance(result_field, str):
        result_field_name = result_field

        result_field_index = vector_layer_fields.indexFromName(result_field_name)
        if result_field_index == -1:
            name_from_variable = qgis.core.QgsExpressionContextUtils.layerScope(vector_layer).variable(field_var_name(result_field_name))
            result_field_index = vector_layer_fields.indexFromName(name_from_variable)
            if result_field_index != -1: result_field_name = name_from_variable

        if result_field_index != -1: result_field = vector_layer_fields[result_field_index]


    elif isinstance(result_field, int):
        result_field_index = result_field
        if not vector_layer_fields.exists(result_field_index):
            print(f"Field with index {result_field_index} not found")
            return
        result_field = vector_layer_fields[result_field_index]
        result_field_name = result_field.name()


    else:
        print(f"The object {result_field} cannot represent the field to update or to create")
        return


    if result_field_index != -1:
        if not check_field_properties_and_setup(
            field = result_field_index,
            layer = vector_layer,
            req_type = req_type,
            req_len = req_len,
            req_prec = req_prec
            ):
            vector_layer.deleteAttribute(result_field_index)
            result_field_index = -1
            
    if result_field_index == -1:
        result_field = add_field(
            layer = vector_layer,
            field_name = result_field_name,
            type = req_type,
            len = req_len,
            prec = req_prec
            )
        result_field_name = result_field.name()
        print(f"Field {result_field_name} added")
        vector_layer_fields = vector_layer.fields()
        result_field_index = vector_layer_fields.indexFromName(result_field_name)


    context = qgis.core.QgsExpressionContext()
    context.appendScopes(qgis.core.QgsExpressionContextUtils.globalProjectLayerScopes(vector_layer))

    if selected_features_only:
        features_to_update = list(vector_layer.getSelectedFeatures())
    else:
        features_to_update = list(vector_layer.getFeatures())


    #prepare the progressMessageBar
    progressMessageBar = qgis.utils.iface.messageBar().createMessage("Evaluating the Field {result_field_name} with the field calculator...")
    progress = qgis.PyQt.QtWidgets.QProgressBar()
    progress.setMaximum(len(features_to_update))
    progress.setAlignment(qgis.PyQt.QtCore.Qt.AlignLeft|qgis.PyQt.QtCore.Qt.AlignVCenter)
    progressMessageBar.layout().addWidget(progress)
    qgis.utils.iface.messageBar().pushWidget(progressMessageBar, qgis.core.Qgis.Info)

    i = 0
    progress.setValue(i)


    for feature in features_to_update:
        context.setFeature(feature)
        result = expression.evaluate(context)

        #feature[result_field_name] = result
        vector_layer.changeAttributeValue(
            fid = feature.id(),
            field = result_field_index,
            newValue = result
            )

        i += 1
        progress.setValue(i)

    qgis.utils.iface.messageBar().clearWidgets()



def check_oriented_bounding_box_aspect_ratio(feature_layer: qgis.core.QgsVectorLayer) -> bool:

    params_oriented_minimum_bounding_box = {
        'INPUT': feature_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    results = processing.run("native:orientedminimumboundingbox", params_oriented_minimum_bounding_box)
    oriented_bounding_box_layer = results['OUTPUT']
    oriented_bounding_box_layer.setName('oriented_bounding_box_layer')
    project = qgis.core.QgsProject.instance()
    project.addMapLayer(oriented_bounding_box_layer, False)
    
    oriented_bounding_box = list(oriented_bounding_box_layer.getFeatures())[0]
    
    oriented_bounding_box_dimensions = [oriented_bounding_box['width'], oriented_bounding_box['height']]
    oriented_bounding_box_dimensions.sort()
    check = oriented_bounding_box_dimensions[1] / oriented_bounding_box_dimensions[0] < 4
    
    project.removeMapLayer(oriented_bounding_box_layer.id())

    return check



def check_convex_shape_extra_area(feature_layer: qgis.core.QgsVectorLayer) -> bool:

    params_convexhull = {
        'INPUT': feature_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    results = processing.run("native:convexhull", params_convexhull)
    convexhull_layer = results['OUTPUT']
    convexhull_layer.setName('convexhull_layer')
    project = qgis.core.QgsProject.instance()
    project.addMapLayer(convexhull_layer, False)
    
    convexhull = list(convexhull_layer.getFeatures())[0]
    
    feature = list(feature_layer.getFeatures())[0]
    feature_area = feature.geometry().area()        #how should any inside atriums be considered? The legislation is not clear on this. In this script they are considered as missing_area

    convexhull_area = convexhull['area']

    missing_area = convexhull_area - feature_area

    check = missing_area / feature_area <= 0.05
    
    project.removeMapLayer(convexhull_layer.id())

    return check

    pass



def features_touching_feature(
    features_layer: qgis.core.QgsVectorLayer,
    feature_layer: qgis.core.QgsVectorLayer
    ) -> qgis.core.QgsVectorLayer:

    params_extract_by_location_touch = {
        'INPUT': features_layer.name(),
        'PREDICATE': [4], #touch
        'INTERSECT': feature_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    extract_by_location_touch_results = processing.run('native:extractbylocation', params_extract_by_location_touch)
    touching_features_layer = extract_by_location_touch_results['OUTPUT']
    return touching_features_layer



def centroids(input_layer: qgis.core.QgsVectorLayer) -> qgis.core.QgsVectorLayer:

    params_centroids = {
        'INPUT': input_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    centroids_results = processing.run('native:centroids', params_centroids)
    centroids_layer = centroids_results['OUTPUT']
    return centroids_layer



def boundary(input_layer: qgis.core.QgsVectorLayer) -> qgis.core.QgsVectorLayer:

    params_boundary = {
        'INPUT': input_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    boundary_results = processing.run('native:boundary', params_boundary)
    boundary_layer = boundary_results['OUTPUT']
    return boundary_layer



def intersection(
    input_layer: qgis.core.QgsVectorLayer,
    overlay_layer: qgis.core.QgsVectorLayer
    ) -> qgis.core.QgsVectorLayer:

    params_intersection = {
        'INPUT': input_layer.name(),
        'OVERLAY': overlay_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    intersection_results = processing.run('native:intersection', params_intersection)
    intersection_layer = intersection_results['OUTPUT']
    return intersection_layer



def explodelines(input_layer: qgis.core.QgsVectorLayer) -> qgis.core.QgsVectorLayer:

    params_explodelines = {
        'INPUT': input_layer.name(),
        'OUTPUT': 'memory:'
        }
    
    exploded_lines_results = processing.run('native:explodelines', params_explodelines)
    exploded_lines_layer = exploded_lines_results['OUTPUT']
    return exploded_lines_layer



def contact_lines_analyses(
    contact_lines_layer: qgis.core.QgsVectorLayer,
    centroid_layer: qgis.core.QgsVectorLayer
    ) -> dict:

    show_temp_layers = True
    if show_temp_layers:
        contact_lines_layer.startEditing()
        side_field = add_field(
            layer = contact_lines_layer,
            field_name = "Side",
            type = qgis.PyQt.QtCore.QVariant.String
            )

    contact_lines = list(contact_lines_layer.getFeatures())
    centroid_feature = list(centroid_layer.getFeatures())[0]
    centroid_point = centroid_feature.geometry().asPoint()

    centroid_pos = np.array([centroid_point.x(), centroid_point.y()])

    directions_distribution = {
        Side.Front : [],
        Side.Left : [],
        Side.Right : [],
        Side.Back : []
        }

    for line_feature in contact_lines:

        line_polyline = line_feature.geometry().asPolyline()
        startpoint_point = line_polyline[0]
        endpoint_point = line_polyline[-1]

        startpoint_pos = np.array([startpoint_point.x(), startpoint_point.y()])
        endpoint_pos = np.array([endpoint_point.x(), endpoint_point.y()])


        contact_angle = rad_angle_in_range(rad_direction_angle(startpoint_pos, endpoint_pos) - np.pi/2)

        centroid_angle_from_startpoint = rad_direction_angle(startpoint_pos, centroid_pos)
        centroid_side_from_startpoint = rad_angle_to_side(centroid_angle_from_startpoint, contact_angle)

        if centroid_side_from_startpoint is not Side.Left:
            centroid_side = centroid_side_from_startpoint
        else:
            centroid_angle_from_endpoint = rad_direction_angle(endpoint_pos, centroid_pos)
            centroid_side_from_endpoint = rad_angle_to_side(centroid_angle_from_endpoint, contact_angle)

            if centroid_side_from_endpoint is Side.Right:
                centroid_side = Side.Front
            else: centroid_side = centroid_side_from_endpoint

        if show_temp_layers:
            contact_lines_layer.changeAttributeValue(
            fid = line_feature.id(),
            field = contact_lines_layer.fields().indexFromName(side_field.name()),
            newValue = centroid_side.value
            )

        directions_distribution[centroid_side].append({
            'angle' : contact_angle,
            'length' : distance(startpoint_pos, endpoint_pos)
            })

    if show_temp_layers:
        contact_lines_layer.commitChanges()

    #sort the lists of dictionaries, in the dictionary, by the angle value
    for k, v in directions_distribution.items():
        v.sort(key = lambda d: d['angle'])

    return directions_distribution



def rad_direction_angle(
    startpoint: np.array,
    endpoint: np.array,
    ) -> float:

    return np.arctan2(endpoint[1] - startpoint[1], endpoint[0] - startpoint[0])



def distance(
    point1: np.array,
    point2: np.array
    ) -> float:
    
    return np.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2)



def rad_angle_in_range(rad_angle: float):
    
    while not -np.pi < rad_angle <= np.pi :
        if rad_angle <= -np.pi :
            rad_angle += np.pi*2
        elif rad_angle > np.pi:
            rad_angle -= np.pi*2

    return rad_angle



def rad_angle_to_side(
    angle: float,
    reference_angle: float = 0.
    ):

    angle -= reference_angle
    angle = rad_angle_in_range(angle)

    if angle == 0.: return Side.Front
    elif angle < 0.:
        if angle > -np.pi/2 : return Side.Right
    else:
        if angle < np.pi/2 : return Side.Left

    return Side.Back



def leftandrightsides_to_front(
    directions_distribution: dict
    ) -> dict:

    if not (directions_distribution[Side.Left] and directions_distribution[Side.Right]): return directions_distribution

    new_front_directions = []
    tolerance = np.pi/8
    

    for leftdir in directions_distribution[Side.Left]:
        
        rightdir = min(directions_distribution[Side.Right], key=(lambda dir1, dir2=leftdir: min_angle_between_directions(dir1['angle'], dir2['angle'])))

        if rightdir and min_angle_between_directions(rightdir['angle'], leftdir['angle']) < tolerance:
            new_front_dir = {
                'angle': bisector(rightdir['angle'], leftdir['angle']),
                'length': rightdir['length'] + leftdir['length']
                }
            if new_front_dir not in new_front_directions: new_front_directions.append(new_front_dir)
    

    for rightdir in directions_distribution[Side.Right]:
        
        leftdir = min(directions_distribution[Side.Left], key=(lambda dir1, dir2=rightdir: min_angle_between_directions(dir2['angle'], dir1['angle'])))

        if leftdir and min_angle_between_directions(rightdir['angle'], leftdir['angle']) < tolerance:
            new_front_dir = {
                'angle': bisector(rightdir['angle'], leftdir['angle']),
                'length': rightdir['length'] + leftdir['length']
                }
            if new_front_dir not in new_front_directions: new_front_directions.append(new_front_dir)


    directions_distribution[Side.Front].extend(new_front_directions)

    return directions_distribution



def directions_distribution_analysis(
    directions_distribution: dict
    ) -> PlanLoc:

    if len(directions_distribution[Side.Front]) < 2: return PlanLoc.End

    frontdirs = [direction['angle'] for direction in directions_distribution[Side.Front]]

    global_max_span_angle = 0

    for direction in frontdirs:
        max_span_angle = max([min_angle_between_directions(other_dir, direction) for other_dir in frontdirs])
        if max_span_angle > global_max_span_angle : global_max_span_angle = max_span_angle

    tolerance = np.pi/8

    if global_max_span_angle > np.pi - tolerance:
        return PlanLoc.Center
    elif global_max_span_angle > np.pi/2 - tolerance:
        return PlanLoc.Angle
    else:
        return PlanLoc.End



def min_angle_between_directions(
    direction1: float,
    direction2: float
    ) -> float :

    directions = [direction1, direction2]
    directions.sort()

    angle = directions[1] - directions[0]

    if angle > np.pi : angle = 2*np.pi - angle

    return angle



def bisector(
    direction1: float,
    direction2: float
    ):

    directions = [direction1, direction2]
    directions.sort()

    angle_between = directions[1] - directions[0]
    angle_bisector = (directions[1] - directions[0])/2

    if angle_between > np.pi :
        angle_bisector += np.pi
        angle_bisector = rad_angle_in_range(angle_bisector)

    return angle_bisector



def singlesidedbuffer(
    lines_layer: qgis.core.QgsVectorLayer,
    distance: float,
    side: int
    ):

    params_singlesidedbuffer = {
        'INPUT': lines_layer.name(),
        'DISTANCE': distance,
        'SIDE': side,
        'JOIN_STYLE': 1, #miter
        'OUTPUT': 'memory:'
        }

    singlesidedbuffer_results = processing.run('native:singlesidedbuffer', params_singlesidedbuffer)
    singlesidedbuffer_layer = singlesidedbuffer_results['OUTPUT']
    return singlesidedbuffer_layer



def layer_pairs_field_comparison(
    buffer1_layer: qgis.core.QgsVectorLayer,
    buffer2_layer: qgis.core.QgsVectorLayer,
    field_name: str,
    tolerance: float
    ) -> bool:

    buffer1_features = list(buffer1_layer.getFeatures())
    buffer2_features = list(buffer2_layer.getFeatures())

    if len(buffer1_features) != len(buffer2_features):
        print("{buffer1_layer.name()} and {buffer2_layer.name()} have different number of features")
        return None

    for pair in range(0, len(buffer1_features)):

        value1 = buffer1_features[pair][field_name]
        value2 = buffer2_features[pair][field_name]

        if abs(value1 - value2) > tolerance:
            return False

    return True




class Parameter(object):
    
    def __init__(
        self,
        default_field_name: str,
        building: "Building" = None,
        description: str = '',
        regex_pattern: str = None,
        accepted_values: list[str] = None
        ):

        self.building = building
        self.default_field_name = default_field_name
        self.description = description
        
        if regex_pattern: self.regex_pattern = regex_pattern
        else: self.regex_pattern = default_field_name

        if accepted_values: self.accepted_values = accepted_values
        else: self.accepted_values = self.default_accepted_values()



    building: "Building"
    default_field_name: str
    description: str
    regex_pattern: str
    accepted_values: list[dict]
    value: str

    accepted_values_group_name = "Parameters_Accepted_Values"
    accepted_values_layer_suffix = "_accepted_values"




    def field_var_name(self) -> str:
        return field_var_name(self.default_field_name)



    def accepted_values_layer_name(self) -> str:
        return self.default_field_name + self.accepted_values_layer_suffix



    def default_accepted_values(self) -> list[str]:

        accepted_values_csv_path = Path(__file__).parent / (self.default_field_name + '_accepted_values.csv')

        accepted_values: list[dict] = []

        if accepted_values_csv_path.exists():
            print(accepted_values_csv_path)
            with open(accepted_values_csv_path) as accepted_values_csv:
                for row in csv.DictReader(accepted_values_csv):
                    accepted_values.append(row)

        return accepted_values



    def __str__(self):
        return f'Input Parameter with default_field_name = {self.default_field_name}'



    def check_layer_setup(
        self,
        buildings_layer: qgis.core.QgsVectorLayer
        ):

        if self.accepted_values:
            lenght = max([len(av['value']) for av in self.accepted_values])
        else: lenght = 5

        check_layer_field_var_and_setup(
            main_layer = buildings_layer,
            default_field_name = self.default_field_name,
            req_type = qgis.PyQt.QtCore.QVariant.String,
            req_len = lenght
            )

        self.accepted_values_setup(building_layer=buildings_layer)



    def accepted_values_setup(
        self,
        building_layer: qgis.core.QgsVectorLayer
        ):

        group = self.check_accepted_values_group_presence()

        if not group: group = create_group(name=self.accepted_values_group_name, under_layer=building_layer)

        accepted_values_layer_list = layer_from_name(self.accepted_values_layer_name())

        accepted_values_layer_in_group_list = []
        for layer in accepted_values_layer_list:
            if check_layer_in_group(layer=layer, group=group):
                accepted_values_layer_in_group_list.append(layer)

        if accepted_values_layer_in_group_list:
            accepted_values_layer = accepted_values_layer_in_group_list[0]
        elif accepted_values_layer_list:
            accepted_values_layer = accepted_values_layer_list[0]
            move_loaded_layer_in_group(layer=accepted_values_layer, group=group)
        else:
            accepted_values_layer = self.create_layer_from_csv(group=group)


        param_field_name = qgis.core.QgsExpressionContextUtils.layerScope(building_layer).variable(self.field_var_name()) #field you want to relate to another layer
        param_field_idx = building_layer.fields().indexFromName(param_field_name) #field index

        accepted_values_layer_fields = accepted_values_layer.fields()
        value_field_idx = accepted_values_layer_fields.indexFromName('value') #id field of the target layer
        value_field_name = accepted_values_layer_fields.field(value_field_idx).name()
        description_field_idx = accepted_values_layer_fields.indexFromName('description')
        description_field_name = accepted_values_layer_fields.field(description_field_idx).name()

        config = {
            'AllowMulti': False, #don't allow multi value
            'AllowNull': True, #allow NULL value
            'OrderByValue': False, #order by value
            'FilterExpression': '',
            'Key': value_field_name, #id field of the target layer
            'Value': value_field_name, #field from the target layer you want to relate
            'Description': description_field_name,
            'Layer': accepted_values_layer.id(), #target layer
            'UseCompleter': False #True if you want the LineEdit tool, False if you want a list of value from the field of the target layer
            }

        widget_setup = qgis.core.QgsEditorWidgetSetup('ValueRelation',config) #setup a specific widget with Value Relation and the config dict create
        building_layer.setEditorWidgetSetup(param_field_idx, widget_setup) #add the widget to your layer and the field on your layer



    @classmethod
    def check_accepted_values_group_presence(cls):

        project = qgis.core.QgsProject.instance()
        root = project.layerTreeRoot()

        group = root.findGroup(cls.accepted_values_group_name)

        return group



    def create_layer_from_csv(
        self,
        csv_path: Path = None,
        name: str = None,
        group: qgis.core.QgsLayerTreeGroup = None
        ) -> qgis.core.QgsVectorLayer:

        if not name:
            if csv_path: name = csv_path.stem()
            else: name = self.accepted_values_layer_name()

        if not csv_path: csv_path = Path(__file__).parent / (name + '.csv')
        
        if not group: group = qgis.core.QgsProject.instance().layerTreeRoot()

        uri = csv_path.as_uri()
        print(uri)

        layer = qgis.core.QgsVectorLayer(
            path=uri,
            baseName=name,
            providerLib='delimitedtext'
            )
        
        qgis.core.QgsProject.instance().addMapLayer(
            mapLayer=layer,
            addToLegend=False,
            )

        group.insertLayer(index=0, layer=layer)

        return layer



    def update_value_from_qgis(self):
        
        if self.building:
            feature = self.building.feature
            value = feature[qgis.core.QgsExpressionContextUtils.layerScope(self.building.layer).variable(self.field_var_name())]
            
            try:
                if value.isNull(): value = None
            except :
                pass
            self.value = value




class Building(object):

    def __init__(
        self,
        layer: qgis.core.QgsVectorLayer,
        feature: qgis.core.QgsFeature
        ):

        self.layer = layer
        self.feature = feature
        
        self.check_layer_setup(layer=layer)
        
        self.parameters = self.default_parameters()
        for p in self.parameters:
            p.building = self

        self.update_parameters_values_from_qgis()


    
    layer: qgis.core.QgsVectorLayer
    feature: qgis.core.QgsFeature

    sheet: str
    parcels: str


    parameters: list[Parameter]


    sheet_default_field_name = 'Sheet'
    parcels_default_field_name = 'Parcels'


    DSM_default_layer = "DSM"
    DTM_default_layer = "DTM"

    
    DSM_median_default_field = DSM_default_layer + "_median"
    DTM_min_default_field = DTM_default_layer + "_min"

    Floors_raw_default_field = "Floors_raw"



    @classmethod
    def default_parameters(cls) -> list[Parameter]:

        parameters_csv_path = Path(__file__).parent / 'Parameters.csv'
        print(parameters_csv_path)

        default_parameters_list: list[Parameter] = []

        with open(parameters_csv_path) as parameters_csv:
            for row in csv.DictReader(parameters_csv):
                parameter = Parameter(**row)
                print(parameter.accepted_values)
                default_parameters_list.append(parameter)

        return default_parameters_list



    @classmethod
    def check_layer_setup(
        cls,
        layer: qgis.core.QgsVectorLayer,
        check_parameters: list[Parameter] = None
        ):

        #check variables and fields about sheet and parcels
        check_layer_field_var_and_setup(
            main_layer=layer, 
            default_field_name=cls.sheet_default_field_name, 
            req_type=qgis.PyQt.QtCore.QVariant.String, 
            req_len=4
            )
        check_layer_field_var_and_setup(
            main_layer=layer, 
            default_field_name=cls.parcels_default_field_name, 
            req_type=qgis.PyQt.QtCore.QVariant.String, 
            req_len=10
            )

        #check variables and fields about parameters
        if not check_parameters: check_parameters = cls.default_parameters()

        print("Check Parameters:\n" + ", ".join([str(p) for p in check_parameters]))

        for cp in check_parameters: cp.check_layer_setup(buildings_layer=layer)



    def update_parameters_values_from_qgis(self):

        for p in self.parameters:
            p.update_value_from_qgis()



    available_fields_info = {
        sheet_default_field_name: "Cadastral sheet to which the building belongs",
        parcels_default_field_name: "Cadastral building parcels",
        }#insert other fields info when implemented



    @classmethod
    def field_info(
        cls,
        layer: qgis.core.QgsVectorLayer,
        field_name: str
        ):
        
        field_default_name = field_default_name_from_fieldname_in_layer(layer = layer, field_name = field_name)

        if not field_default_name in cls.available_fields_info:
            for p in cls.default_parameters():
                cls.available_fields_info[p.default_field_name] = p.description

        if not field_default_name in cls.available_fields_info:
            info = f'Info not available for the field {field_name}'
        else:
            info = cls.available_fields_info[field_default_name]

        message_box(
            type = MessageBoxType.Information,
            title = f'Field {field_name} info',
            text = info
            )



    @classmethod
    def auto_fill_field_Floors(
        cls,
        buildings_layer: qgis.core.QgsVectorLayer,
        field_name: str,
        selected_features_only: bool = False
        ):

        if not check_layer_layer_var(main_layer = buildings_layer, default_layer_name = cls.DSM_default_layer):
            print(f"The {cls.DSM_default_layer} layer is required")
            message_box(
                type = MessageBoxType.Warning,
                text = f"The {cls.DSM_default_layer} layer is required"
                )
            return

        if not check_layer_layer_var(main_layer = buildings_layer, default_layer_name = cls.DTM_default_layer):
            print(f"The {cls.DTM_default_layer} layer is required")
            message_box(
                type = MessageBoxType.Warning,
                text = f"The {cls.DTM_default_layer} layer is required"
                )
            return


        params_DSM_zonal_stat = {
            'INPUT_RASTER': qgis.core.QgsExpressionContextUtils.layerScope(buildings_layer).variable(layer_var_name(cls.DSM_default_layer)),
            'RASTER_BAND': 1,
            'COLUMN_PREFIX': cls.DSM_default_layer + '_',
            'STATISTICS': [3], #median
            'OUTPUT': 'memory:'
            }

        exec_process_vect_layer_add_results(
            algorithm_name = "native:zonalstatisticsfb",
            parameters = params_DSM_zonal_stat,
            vector_layer = buildings_layer,
            vector_layer_param_name = 'INPUT',
            expected_fields_names_result = [cls.DSM_median_default_field],
            selected_features_only = selected_features_only
            )


        params_DTM_zonal_stat = {
            'INPUT_RASTER': qgis.core.QgsExpressionContextUtils.layerScope(buildings_layer).variable(layer_var_name(cls.DTM_default_layer)),
            'RASTER_BAND': 1,
            'COLUMN_PREFIX': cls.DTM_default_layer + '_',
            'STATISTICS': [5], #min
            'OUTPUT': 'memory:'
            }

        exec_process_vect_layer_add_results(
            algorithm_name = "native:zonalstatisticsfb",
            parameters = params_DTM_zonal_stat,
            vector_layer = buildings_layer,
            vector_layer_param_name = 'INPUT',
            expected_fields_names_result = [cls.DTM_min_default_field],
            selected_features_only = selected_features_only
            )


        floors_expression = 'to_string( if( round( (  "DSM_median" - "DTM_min"  )  / 3 ) < 1, 1, if( round( (  "DSM_median" - "DTM_min"  )  / 3 ) > 6, 6, round( (  "DSM_median" - "DTM_min"  )  / 3 ) ) ) )'

        execute_field_calculator(
            vector_layer = buildings_layer,
            expression = floors_expression,
            result_field = field_name,
            req_type = qgis.PyQt.QtCore.QVariant.String,
            req_len = 1,
            selected_features_only = selected_features_only
            )



    @classmethod
    def auto_fill_field_ShapePlReg(
        cls,
        buildings_layer: qgis.core.QgsVectorLayer,
        field_name: str,
        selected_features_only: bool = False
        ):

        project = qgis.core.QgsProject.instance()


        if selected_features_only:
            features_to_fill = list(buildings_layer.getSelectedFeatures())
        else:
            features_to_fill = list(buildings_layer.getFeatures())


        #prepare the progressMessageBar
        progressMessageBar = qgis.utils.iface.messageBar().createMessage("Filling automatically the field {field_name} ...")
        progress = qgis.PyQt.QtWidgets.QProgressBar()
        progress.setMaximum(len(features_to_fill))
        progress.setAlignment(qgis.PyQt.QtCore.Qt.AlignLeft|qgis.PyQt.QtCore.Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        qgis.utils.iface.messageBar().pushWidget(progressMessageBar, qgis.core.Qgis.Info)

        i = 0
        progress.setValue(i)


        for feature in features_to_fill:

            feature_request = qgis.core.QgsFeatureRequest().setFilterFid(feature.id())

            feature_layer = buildings_layer.materialize(feature_request)
            feature_layer.setName('feature_layer')
            project.addMapLayer(feature_layer, False)

            if check_oriented_bounding_box_aspect_ratio(feature_layer) and check_convex_shape_extra_area(feature_layer):
                shapeplreg = ShapePlReg.Yes
            else:
                shapeplreg = ShapePlReg.No
            
            project.removeMapLayer(feature_layer.id())

            buildings_layer.changeAttributeValue(
                fid = feature.id(),
                field = buildings_layer.fields().indexFromName(field_name),
                newValue = shapeplreg.value
                )

            i += 1
            progress.setValue(i)


        qgis.utils.iface.messageBar().clearWidgets()



    @classmethod
    def auto_fill_field_PlanLoc(
        cls,
        buildings_layer: qgis.core.QgsVectorLayer,
        field_name: str,
        selected_features_only: bool = False
        ):

        if selected_features_only:
            features_to_fill = list(buildings_layer.getSelectedFeatures())
        else:
            features_to_fill = list(buildings_layer.getFeatures())

        show_temp_layers = False

        main_group = create_group(
            name="PlanLoc",
            above_layer=buildings_layer
            )
        main_group_name = main_group.name()


        #prepare the progressMessageBar
        progressMessageBar = qgis.utils.iface.messageBar().createMessage("Filling automatically the field {field_name} ...")
        progress = qgis.PyQt.QtWidgets.QProgressBar()
        progress.setMaximum(len(features_to_fill))
        progress.setAlignment(qgis.PyQt.QtCore.Qt.AlignLeft|qgis.PyQt.QtCore.Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        qgis.utils.iface.messageBar().pushWidget(progressMessageBar, qgis.core.Qgis.Info)

        i = 0
        progress.setValue(i)


        for feature in features_to_fill:

            feature_group_name=feature[qgis.core.QgsExpressionContextUtils.layerScope(buildings_layer).variable(field_var_name(cls.parcels_default_field_name))]
            if (not feature_group_name) or feature_group_name == qgis.core.NULL:
                feature_group_name = "no parcels"
            feature_group_name = main_group_name + " " + feature_group_name

            feature_group = create_group(
                name=feature_group_name,
                in_group=main_group
                )
            feature_group_name = feature_group.name()

            #creates feature_layer
            feature_request = qgis.core.QgsFeatureRequest().setFilterFid(feature.id())
            feature_layer = buildings_layer.materialize(feature_request)
            add_layer_to_project(layer=feature_layer, in_group=feature_group, name=f'{feature_group_name} feature_layer')

            #creates the touching_buildings_layer
            touching_buildings_layer = features_touching_feature(buildings_layer, feature_layer)
            add_layer_to_project(layer=touching_buildings_layer, in_group=feature_group, name=f'{feature_group_name} touching_buildings_layer')

            if list(touching_buildings_layer.getFeatures()):

                #creates centroid_layer
                centroid_layer = centroids(feature_layer)
                add_layer_to_project(layer=centroid_layer, in_group=feature_group, name=f'{feature_group_name} centroid_layer')

                #creates boundary_layer
                boundary_layer = boundary(feature_layer)
                add_layer_to_project(layer=boundary_layer, in_group=feature_group, name=f'{feature_group_name} boundary_layer')

                #creates touching_boundary_layer
                touching_boundary_layer = boundary(touching_buildings_layer)
                add_layer_to_project(layer=touching_boundary_layer, in_group=feature_group, name=f'{feature_group_name} touching_boundary_layer')

                #creates boundary_intersection_layer
                boundary_intersection_layer = intersection(input_layer = boundary_layer, overlay_layer = touching_boundary_layer)
                add_layer_to_project(layer=boundary_intersection_layer, in_group=feature_group, name=f'{feature_group_name} boundary_intersection_layer')

                #creates contact_lines_layer exploding the boundary_intersection_layer
                contact_lines_layer = explodelines(boundary_intersection_layer)
                add_layer_to_project(layer=contact_lines_layer, in_group=feature_group, name=f'{feature_group_name} contact_lines_layer')


                #analyse the contact lines
                directions_distribution = contact_lines_analyses(contact_lines_layer, centroid_layer)

                #combine left and right contacts in front contact
                directions_distribution = leftandrightsides_to_front(directions_distribution)

                #determine the planimetric location of the building in the aggregate
                planloc = directions_distribution_analysis(directions_distribution)

            else:
                planloc = PlanLoc.Isolated


            if show_temp_layers:
                feature_group.setItemVisibilityChecked(False)
                feature_group.setExpanded(False)
            else:
                remove_group_and_all_children(feature_group)


            buildings_layer.changeAttributeValue(
                fid = feature.id(),
                field = buildings_layer.fields().indexFromName(field_name),
                newValue = planloc.value
                )


            i += 1
            progress.setValue(i)


        qgis.utils.iface.messageBar().clearWidgets()


        if show_temp_layers:
            main_group.setExpanded(False)
        else:
            remove_group_and_all_children(main_group)



    @classmethod
    def auto_fill_field_DifHeight(
        cls,
        buildings_layer: qgis.core.QgsVectorLayer,
        field_name: str,
        selected_features_only: bool = False
        ):

        if not check_layer_layer_var(main_layer = buildings_layer, default_layer_name = cls.DSM_default_layer):
            print(f"The {cls.DSM_default_layer} layer is required")
            message_box(
                type = MessageBoxType.Warning,
                text = f"The {cls.DSM_default_layer} layer is required"
                )
            return


        project = qgis.core.QgsProject.instance()


        if selected_features_only:
            features_to_fill = list(buildings_layer.getSelectedFeatures())
        else:
            features_to_fill = list(buildings_layer.getFeatures())

        show_temp_layers = True
        buffer_distance = 1.
        height_tolerance = 2.


        main_group = create_group(
            name="DifHeight",
            above_layer=buildings_layer
            )
        main_group_name = main_group.name()


        #prepare the progressMessageBar
        progressMessageBar = qgis.utils.iface.messageBar().createMessage("Filling automatically the field {field_name} ...")
        progress = qgis.PyQt.QtWidgets.QProgressBar()
        progress.setMaximum(len(features_to_fill))
        progress.setAlignment(qgis.PyQt.QtCore.Qt.AlignLeft|qgis.PyQt.QtCore.Qt.AlignVCenter)
        progressMessageBar.layout().addWidget(progress)
        qgis.utils.iface.messageBar().pushWidget(progressMessageBar, qgis.core.Qgis.Info)

        i = 0
        progress.setValue(i)


        for feature in features_to_fill:

            feature_group_name=feature[qgis.core.QgsExpressionContextUtils.layerScope(buildings_layer).variable(field_var_name(cls.parcels_default_field_name))]
            if (not feature_group_name) or feature_group_name == qgis.core.NULL:
                feature_group_name = "no parcels"
            feature_group_name = main_group_name + " " + feature_group_name

            feature_group = create_group(
                name=feature_group_name,
                in_group=main_group
                )
            feature_group_name = feature_group.name()

            #creates feature_layer
            feature_request = qgis.core.QgsFeatureRequest().setFilterFid(feature.id())
            feature_layer = buildings_layer.materialize(feature_request)
            add_layer_to_project(layer=feature_layer, in_group=feature_group, name=f'{feature_group_name} feature_layer')

            #creates the touching_buildings_layer
            touching_buildings_layer = features_touching_feature(buildings_layer, feature_layer)
            add_layer_to_project(layer=touching_buildings_layer, in_group=feature_group, name=f'{feature_group_name} touching_buildings_layer')

            if list(touching_buildings_layer.getFeatures()):

                #creates boundary_layer
                boundary_layer = boundary(feature_layer)
                add_layer_to_project(layer=boundary_layer, in_group=feature_group, name=f'{feature_group_name} boundary_layer')

                #creates touching_boundary_layer
                touching_boundary_layer = boundary(touching_buildings_layer)
                add_layer_to_project(layer=touching_boundary_layer, in_group=feature_group, name=f'{feature_group_name} touching_boundary_layer')

                #creates boundary_intersection_layer
                boundary_intersection_layer = intersection(input_layer = boundary_layer, overlay_layer = touching_boundary_layer)
                add_layer_to_project(layer=boundary_intersection_layer, in_group=feature_group, name=f'{feature_group_name} boundary_intersection_layer')

                #creates contact_lines_layer exploding the boundary_intersection_layer
                contact_lines_layer = explodelines(boundary_intersection_layer)
                add_layer_to_project(layer=contact_lines_layer, in_group=feature_group, name=f'{feature_group_name} contact_lines_layer')

                #creates inward_buffer_layer
                inward_buffer_layer = singlesidedbuffer(lines_layer=contact_lines_layer, distance=buffer_distance, side=1)
                add_layer_to_project(layer=inward_buffer_layer, in_group=feature_group, name=f'{feature_group_name} inward_buffer_layer')

                #creates outward_buffer_layer
                outward_buffer_layer = singlesidedbuffer(lines_layer=contact_lines_layer, distance=buffer_distance, side=0)
                add_layer_to_project(layer=outward_buffer_layer, in_group=feature_group, name=f'{feature_group_name} outward_buffer_layer')


                #zonalstat parameters for DSM_median
                params_DSM_zonal_stat = {
                    'INPUT_RASTER': qgis.core.QgsExpressionContextUtils.layerScope(buildings_layer).variable(layer_var_name(cls.DSM_default_layer)),
                    'RASTER_BAND': 1,
                    'COLUMN_PREFIX': cls.DSM_default_layer + '_',
                    'STATISTICS': [3], #median
                    'OUTPUT': 'memory:'
                    }

                #DSM_median in inward_buffer_layer
                inward_buffer_layer.startEditing()
                exec_process_vect_layer_add_results(
                    algorithm_name = "native:zonalstatisticsfb",
                    parameters = params_DSM_zonal_stat,
                    vector_layer = inward_buffer_layer,
                    vector_layer_param_name = 'INPUT',
                    expected_fields_names_result = [cls.DSM_median_default_field],
                    selected_features_only = False
                    )
                inward_buffer_layer.commitChanges()

                #DSM_median in outward_buffer_layer
                outward_buffer_layer.startEditing()
                exec_process_vect_layer_add_results(
                    algorithm_name = "native:zonalstatisticsfb",
                    parameters = params_DSM_zonal_stat,
                    vector_layer = outward_buffer_layer,
                    vector_layer_param_name = 'INPUT',
                    expected_fields_names_result = [cls.DSM_median_default_field],
                    selected_features_only = False
                    )
                outward_buffer_layer.commitChanges()


                comparison = layer_pairs_field_comparison(
                    buffer1_layer=inward_buffer_layer,
                    buffer2_layer=outward_buffer_layer,
                    field_name=cls.DSM_median_default_field,
                    tolerance=height_tolerance
                    )

                if comparison == None: difheight = DifHeight.Isolated
                elif comparison: difheight = DifHeight.No
                else: difheight = DifHeight.Yes

            else:
                difheight = DifHeight.Isolated


            if show_temp_layers:
                feature_group.setItemVisibilityChecked(False)
                feature_group.setExpanded(False)
            else:
                remove_group_and_all_children(feature_group)

            buildings_layer.changeAttributeValue(
                fid = feature.id(),
                field = buildings_layer.fields().indexFromName(field_name),
                newValue = difheight.value
                )


            i += 1
            progress.setValue(i)


        qgis.utils.iface.messageBar().clearWidgets()


        if show_temp_layers:
            main_group.setExpanded(False)
        else:
            remove_group_and_all_children(main_group)



    @classmethod
    def auto_fill_field(
        cls,
        buildings_layer: qgis.core.QgsVectorLayer,
        field_name: str,
        selected_features_only: bool = False,
        clicked_feature_id: int = None
        ):

        field_default_name = field_default_name_from_fieldname_in_layer(layer = buildings_layer, field_name = field_name)

        if not field_default_name in cls.available_fields_auto_fill:
            print(f'Auto Fill not available for the field {field_name}')
            message_box(
                type = MessageBoxType.Information,
                text = f'Auto Fill not available for the field {field_name}'
                )
            return

        if selected_features_only:
            if clicked_feature_id:
                selected_features_ids = buildings_layer.selectedFeatureIds()
                if not clicked_feature_id in selected_features_ids:
                    buildings_layer.deselect(selected_features_ids)
                    buildings_layer.select(clicked_feature_id)

        cls.available_fields_auto_fill[field_default_name](
            buildings_layer,
            field_name,
            selected_features_only
            )



Building.available_fields_auto_fill = {
    "Floors": Building.auto_fill_field_Floors,
    "ShapePlReg": Building.auto_fill_field_ShapePlReg,
    "PlanLoc": Building.auto_fill_field_PlanLoc,
    "DifHeight": Building.auto_fill_field_DifHeight
    }#insert other fields auto fill when implemented
